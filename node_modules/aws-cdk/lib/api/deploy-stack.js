"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.destroyStack = exports.deployStack = void 0;
const cxapi = require("@aws-cdk/cx-api");
const colors = require("colors/safe");
const uuid = require("uuid");
const assets_1 = require("../assets");
const logging_1 = require("../logging");
const serialize_1 = require("../serialize");
const asset_manifest_builder_1 = require("../util/asset-manifest-builder");
const asset_publishing_1 = require("../util/asset-publishing");
const content_hash_1 = require("../util/content-hash");
const hotswap_deployments_1 = require("./hotswap-deployments");
const common_1 = require("./hotswap/common");
const evaluate_cloudformation_template_1 = require("./hotswap/evaluate-cloudformation-template");
const cloudformation_1 = require("./util/cloudformation");
const stack_activity_monitor_1 = require("./util/cloudformation/stack-activity-monitor");
const LARGE_TEMPLATE_SIZE_KB = 50;
async function deployStack(options) {
    const stackArtifact = options.stack;
    const stackEnv = options.resolvedEnvironment;
    options.sdk.appendCustomUserAgent(options.extraUserAgent);
    const cfn = options.sdk.cloudFormation();
    const deployName = options.deployName || stackArtifact.stackName;
    let cloudFormationStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
    if (cloudFormationStack.stackStatus.isCreationFailure) {
        logging_1.debug(`Found existing stack ${deployName} that had previously failed creation. Deleting it before attempting to re-create it.`);
        await cfn.deleteStack({ StackName: deployName }).promise();
        const deletedStack = await cloudformation_1.waitForStackDelete(cfn, deployName);
        if (deletedStack && deletedStack.stackStatus.name !== 'DELETE_COMPLETE') {
            throw new Error(`Failed deleting stack ${deployName} that had previously failed creation (current state: ${deletedStack.stackStatus})`);
        }
        // Update variable to mark that the stack does not exist anymore, but avoid
        // doing an actual lookup in CloudFormation (which would be silly to do if
        // we just deleted it).
        cloudFormationStack = cloudformation_1.CloudFormationStack.doesNotExist(cfn, deployName);
    }
    // Detect "legacy" assets (which remain in the metadata) and publish them via
    // an ad-hoc asset manifest, while passing their locations via template
    // parameters.
    const legacyAssets = new asset_manifest_builder_1.AssetManifestBuilder();
    const assetParams = await assets_1.addMetadataAssetsToManifest(stackArtifact, legacyAssets, options.toolkitInfo, options.reuseAssets);
    const finalParameterValues = { ...options.parameters, ...assetParams };
    const templateParams = cloudformation_1.TemplateParameters.fromTemplate(stackArtifact.template);
    const stackParams = options.usePreviousParameters
        ? templateParams.updateExisting(finalParameterValues, cloudFormationStack.parameters)
        : templateParams.supplyAll(finalParameterValues);
    if (await canSkipDeploy(options, cloudFormationStack, stackParams.hasChanges(cloudFormationStack.parameters))) {
        logging_1.debug(`${deployName}: skipping deployment (use --force to override)`);
        // if we can skip deployment and we are performing a hotswap, let the user know
        // that no hotswap deployment happened
        if (options.hotswap) {
            logging_1.print(`\n ${common_1.ICON} %s\n`, colors.bold('hotswap deployment skipped - no changes were detected (use --force to override)'));
        }
        return {
            noOp: true,
            outputs: cloudFormationStack.outputs,
            stackArn: cloudFormationStack.stackId,
            stackArtifact,
        };
    }
    else {
        logging_1.debug(`${deployName}: deploying...`);
    }
    const bodyParameter = await makeBodyParameter(stackArtifact, options.resolvedEnvironment, legacyAssets, options.toolkitInfo, options.sdk);
    await asset_publishing_1.publishAssets(legacyAssets.toManifest(stackArtifact.assembly.directory), options.sdkProvider, stackEnv);
    if (options.hotswap) {
        // attempt to short-circuit the deployment if possible
        try {
            const hotswapDeploymentResult = await hotswap_deployments_1.tryHotswapDeployment(options.sdkProvider, assetParams, cloudFormationStack, stackArtifact);
            if (hotswapDeploymentResult) {
                return hotswapDeploymentResult;
            }
            logging_1.print('Could not perform a hotswap deployment, as the stack %s contains non-Asset changes', stackArtifact.displayName);
        }
        catch (e) {
            if (!(e instanceof evaluate_cloudformation_template_1.CfnEvaluationException)) {
                throw e;
            }
            logging_1.print('Could not perform a hotswap deployment, because the CloudFormation template could not be resolved: %s', e.message);
        }
        logging_1.print('Falling back to doing a full deployment');
    }
    // could not short-circuit the deployment, perform a full CFN deploy instead
    return prepareAndExecuteChangeSet(options, cloudFormationStack, stackArtifact, stackParams, bodyParameter);
}
exports.deployStack = deployStack;
async function prepareAndExecuteChangeSet(options, cloudFormationStack, stackArtifact, stackParams, bodyParameter) {
    var _a, _b, _c, _d;
    // if we got here, and hotswap is enabled, that means changes couldn't be hotswapped,
    // and we had to fall back on a full deployment. Note that fact in our User-Agent
    if (options.hotswap) {
        options.sdk.appendCustomUserAgent('cdk-hotswap/fallback');
    }
    const cfn = options.sdk.cloudFormation();
    const deployName = (_a = options.deployName) !== null && _a !== void 0 ? _a : stackArtifact.stackName;
    const changeSetName = (_b = options.changeSetName) !== null && _b !== void 0 ? _b : 'cdk-deploy-change-set';
    if (cloudFormationStack.exists) {
        //Delete any existing change sets generated by CDK since change set names must be unique.
        //The delete request is successful as long as the stack exists (even if the change set does not exist).
        logging_1.debug(`Removing existing change set with name ${changeSetName} if it exists`);
        await cfn.deleteChangeSet({ StackName: deployName, ChangeSetName: changeSetName }).promise();
    }
    const update = cloudFormationStack.exists && cloudFormationStack.stackStatus.name !== 'REVIEW_IN_PROGRESS';
    logging_1.debug(`Attempting to create ChangeSet with name ${changeSetName} to ${update ? 'update' : 'create'} stack ${deployName}`);
    logging_1.print('%s: creating CloudFormation changeset...', colors.bold(deployName));
    const executionId = uuid.v4();
    const changeSet = await cfn.createChangeSet({
        StackName: deployName,
        ChangeSetName: changeSetName,
        ChangeSetType: update ? 'UPDATE' : 'CREATE',
        Description: `CDK Changeset for execution ${executionId}`,
        TemplateBody: bodyParameter.TemplateBody,
        TemplateURL: bodyParameter.TemplateURL,
        Parameters: stackParams.apiParameters,
        RoleARN: options.roleArn,
        NotificationARNs: options.notificationArns,
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
        Tags: options.tags,
    }).promise();
    logging_1.debug('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id);
    const changeSetDescription = await cloudformation_1.waitForChangeSet(cfn, deployName, changeSetName);
    // Update termination protection only if it has changed.
    const terminationProtection = (_c = stackArtifact.terminationProtection) !== null && _c !== void 0 ? _c : false;
    if (!!cloudFormationStack.terminationProtection !== terminationProtection) {
        logging_1.debug('Updating termination protection from %s to %s for stack %s', cloudFormationStack.terminationProtection, terminationProtection, deployName);
        await cfn.updateTerminationProtection({
            StackName: deployName,
            EnableTerminationProtection: terminationProtection,
        }).promise();
        logging_1.debug('Termination protection updated to %s for stack %s', terminationProtection, deployName);
    }
    if (cloudformation_1.changeSetHasNoChanges(changeSetDescription)) {
        logging_1.debug('No changes are to be performed on %s.', deployName);
        if (options.execute) {
            logging_1.debug('Deleting empty change set %s', changeSet.Id);
            await cfn.deleteChangeSet({ StackName: deployName, ChangeSetName: changeSetName }).promise();
        }
        return { noOp: true, outputs: cloudFormationStack.outputs, stackArn: changeSet.StackId, stackArtifact };
    }
    const execute = options.execute === undefined ? true : options.execute;
    if (execute) {
        logging_1.debug('Initiating execution of changeset %s on stack %s', changeSet.Id, deployName);
        const shouldDisableRollback = options.rollback === false;
        // Do a bit of contortions to only pass the `DisableRollback` flag if it's true. That way,
        // CloudFormation won't balk at the unrecognized option in regions where the feature is not available yet.
        const disableRollback = shouldDisableRollback ? { DisableRollback: true } : undefined;
        await cfn.executeChangeSet({ StackName: deployName, ChangeSetName: changeSetName, ...disableRollback }).promise();
        // eslint-disable-next-line max-len
        const changeSetLength = ((_d = changeSetDescription.Changes) !== null && _d !== void 0 ? _d : []).length;
        const monitor = options.quiet ? undefined : stack_activity_monitor_1.StackActivityMonitor.withDefaultPrinter(cfn, deployName, stackArtifact, {
            // +1 for the extra event emitted from updates.
            resourcesTotal: cloudFormationStack.exists ? changeSetLength + 1 : changeSetLength,
            progress: options.progress,
            changeSetCreationTime: changeSetDescription.CreationTime,
        }).start();
        logging_1.debug('Execution of changeset %s on stack %s has started; waiting for the update to complete...', changeSet.Id, deployName);
        try {
            const finalStack = await cloudformation_1.waitForStackDeploy(cfn, deployName);
            // This shouldn't really happen, but catch it anyway. You never know.
            if (!finalStack) {
                throw new Error('Stack deploy failed (the stack disappeared while we were deploying it)');
            }
            cloudFormationStack = finalStack;
        }
        finally {
            await (monitor === null || monitor === void 0 ? void 0 : monitor.stop());
        }
        logging_1.debug('Stack %s has completed updating', deployName);
    }
    else {
        logging_1.print('Changeset %s created and waiting in review for manual execution (--no-execute)', changeSet.Id);
    }
    return { noOp: false, outputs: cloudFormationStack.outputs, stackArn: changeSet.StackId, stackArtifact };
}
/**
 * Prepares the body parameter for +CreateChangeSet+.
 *
 * If the template is small enough to be inlined into the API call, just return
 * it immediately.
 *
 * Otherwise, add it to the asset manifest to get uploaded to the staging
 * bucket and return its coordinates. If there is no staging bucket, an error
 * is thrown.
 *
 * @param stack     the synthesized stack that provides the CloudFormation template
 * @param toolkitInfo information about the toolkit stack
 */
async function makeBodyParameter(stack, resolvedEnvironment, assetManifest, toolkitInfo, sdk) {
    // If the template has already been uploaded to S3, just use it from there.
    if (stack.stackTemplateAssetObjectUrl) {
        return { TemplateURL: restUrlFromManifest(stack.stackTemplateAssetObjectUrl, resolvedEnvironment, sdk) };
    }
    // Otherwise, pass via API call (if small) or upload here (if large)
    const templateJson = serialize_1.toYAML(stack.template);
    if (templateJson.length <= LARGE_TEMPLATE_SIZE_KB * 1024) {
        return { TemplateBody: templateJson };
    }
    if (!toolkitInfo.found) {
        logging_1.error(`The template for stack "${stack.displayName}" is ${Math.round(templateJson.length / 1024)}KiB. ` +
            `Templates larger than ${LARGE_TEMPLATE_SIZE_KB}KiB must be uploaded to S3.\n` +
            'Run the following command in order to setup an S3 bucket in this environment, and then re-deploy:\n\n', colors.blue(`\t$ cdk bootstrap ${resolvedEnvironment.name}\n`));
        throw new Error('Template too large to deploy ("cdk bootstrap" is required)');
    }
    const templateHash = content_hash_1.contentHash(templateJson);
    const key = `cdk/${stack.id}/${templateHash}.yml`;
    assetManifest.addFileAsset(templateHash, {
        path: stack.templateFile,
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    const templateURL = `${toolkitInfo.bucketUrl}/${key}`;
    logging_1.debug('Storing template in S3 at:', templateURL);
    return { TemplateURL: templateURL };
}
async function destroyStack(options) {
    const deployName = options.deployName || options.stack.stackName;
    const cfn = options.sdk.cloudFormation();
    const currentStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
    if (!currentStack.exists) {
        return;
    }
    const monitor = options.quiet ? undefined : stack_activity_monitor_1.StackActivityMonitor.withDefaultPrinter(cfn, deployName, options.stack).start();
    try {
        await cfn.deleteStack({ StackName: deployName, RoleARN: options.roleArn }).promise();
        const destroyedStack = await cloudformation_1.waitForStackDelete(cfn, deployName);
        if (destroyedStack && destroyedStack.stackStatus.name !== 'DELETE_COMPLETE') {
            throw new Error(`Failed to destroy ${deployName}: ${destroyedStack.stackStatus}`);
        }
    }
    finally {
        if (monitor) {
            await monitor.stop();
        }
    }
}
exports.destroyStack = destroyStack;
/**
 * Checks whether we can skip deployment
 *
 * We do this in a complicated way by preprocessing (instead of just
 * looking at the changeset), because if there are nested stacks involved
 * the changeset will always show the nested stacks as needing to be
 * updated, and the deployment will take a long time to in effect not
 * do anything.
 */
async function canSkipDeploy(deployStackOptions, cloudFormationStack, parameterChanges) {
    var _a;
    const deployName = deployStackOptions.deployName || deployStackOptions.stack.stackName;
    logging_1.debug(`${deployName}: checking if we can skip deploy`);
    // Forced deploy
    if (deployStackOptions.force) {
        logging_1.debug(`${deployName}: forced deployment`);
        return false;
    }
    // Creating changeset only (default true), never skip
    if (deployStackOptions.execute === false) {
        logging_1.debug(`${deployName}: --no-execute, always creating change set`);
        return false;
    }
    // No existing stack
    if (!cloudFormationStack.exists) {
        logging_1.debug(`${deployName}: no existing stack`);
        return false;
    }
    // Template has changed (assets taken into account here)
    if (JSON.stringify(deployStackOptions.stack.template) !== JSON.stringify(await cloudFormationStack.template())) {
        logging_1.debug(`${deployName}: template has changed`);
        return false;
    }
    // Tags have changed
    if (!compareTags(cloudFormationStack.tags, (_a = deployStackOptions.tags) !== null && _a !== void 0 ? _a : [])) {
        logging_1.debug(`${deployName}: tags have changed`);
        return false;
    }
    // Termination protection has been updated
    if (!!deployStackOptions.stack.terminationProtection !== !!cloudFormationStack.terminationProtection) {
        logging_1.debug(`${deployName}: termination protection has been updated`);
        return false;
    }
    // Parameters have changed
    if (parameterChanges) {
        if (parameterChanges === 'ssm') {
            logging_1.debug(`${deployName}: some parameters come from SSM so we have to assume they may have changed`);
        }
        else {
            logging_1.debug(`${deployName}: parameters have changed`);
        }
        return false;
    }
    // Existing stack is in a failed state
    if (cloudFormationStack.stackStatus.isFailure) {
        logging_1.debug(`${deployName}: stack is in a failure state`);
        return false;
    }
    // We can skip deploy
    return true;
}
/**
 * Compares two list of tags, returns true if identical.
 */
function compareTags(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (const aTag of a) {
        const bTag = b.find(tag => tag.Key === aTag.Key);
        if (!bTag || bTag.Value !== aTag.Value) {
            return false;
        }
    }
    return true;
}
/**
 * Format an S3 URL in the manifest for use with CloudFormation
 *
 * Replaces environment placeholders (which this field may contain),
 * and reformats s3://.../... urls into S3 REST URLs (which CloudFormation
 * expects)
 */
function restUrlFromManifest(url, environment, sdk) {
    const doNotUseMarker = '**DONOTUSE**';
    // This URL may contain placeholders, so still substitute those.
    url = cxapi.EnvironmentPlaceholders.replace(url, {
        accountId: environment.account,
        region: environment.region,
        partition: doNotUseMarker,
    });
    // Yes, this is extremely crude, but we don't actually need this so I'm not inclined to spend
    // a lot of effort trying to thread the right value to this location.
    if (url.indexOf(doNotUseMarker) > -1) {
        throw new Error('Cannot use \'${AWS::Partition}\' in the \'stackTemplateAssetObjectUrl\' field');
    }
    const s3Url = url.match(/s3:\/\/([^/]+)\/(.*)$/);
    if (!s3Url) {
        return url;
    }
    // We need to pass an 'https://s3.REGION.amazonaws.com[.cn]/bucket/object' URL to CloudFormation, but we
    // got an 's3://bucket/object' URL instead. Construct the rest API URL here.
    const bucketName = s3Url[1];
    const objectKey = s3Url[2];
    const urlSuffix = sdk.getEndpointSuffix(environment.region);
    return `https://s3.${environment.region}.${urlSuffix}/${bucketName}/${objectKey}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95LXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGVwbG95LXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUF5QztBQUN6QyxzQ0FBc0M7QUFDdEMsNkJBQTZCO0FBQzdCLHNDQUF3RDtBQUV4RCx3Q0FBaUQ7QUFDakQsNENBQXNDO0FBQ3RDLDJFQUFzRTtBQUN0RSwrREFBeUQ7QUFDekQsdURBQW1EO0FBRW5ELCtEQUE2RDtBQUM3RCw2Q0FBd0M7QUFDeEMsaUdBQW9GO0FBRXBGLDBEQUcrQjtBQUMvQix5RkFBMkc7QUErSzNHLE1BQU0sc0JBQXNCLEdBQUcsRUFBRSxDQUFDO0FBRTNCLEtBQUssVUFBVSxXQUFXLENBQUMsT0FBMkI7SUFDM0QsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUVwQyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUM7SUFFN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDMUQsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN6QyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxJQUFJLGFBQWEsQ0FBQyxTQUFTLENBQUM7SUFDakUsSUFBSSxtQkFBbUIsR0FBRyxNQUFNLG9DQUFtQixDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFNUUsSUFBSSxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsaUJBQWlCLEVBQUU7UUFDckQsZUFBSyxDQUFDLHdCQUF3QixVQUFVLHNGQUFzRixDQUFDLENBQUM7UUFDaEksTUFBTSxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDM0QsTUFBTSxZQUFZLEdBQUcsTUFBTSxtQ0FBa0Is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RUFBK0UsQ0FBQyxDQUFDO0tBQ2xHO0lBRUQsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQ2pELElBQUksQ0FBQyxLQUFLLEVBQUU7UUFBRSxPQUFPLEdBQUcsQ0FBQztLQUFFO0lBRTNCLHdHQUF3RztJQUN4Ryw0RUFBNEU7SUFDNUUsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVCLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUzQixNQUFNLFNBQVMsR0FBVyxHQUFHLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3BFLE9BQU8sY0FBYyxXQUFXLENBQUMsTUFBTSxJQUFJLFNBQVMsSUFBSSxVQUFVLElBQUksU0FBUyxFQUFFLENBQUM7QUFDcEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JzL3NhZmUnO1xuaW1wb3J0ICogYXMgdXVpZCBmcm9tICd1dWlkJztcbmltcG9ydCB7IGFkZE1ldGFkYXRhQXNzZXRzVG9NYW5pZmVzdCB9IGZyb20gJy4uL2Fzc2V0cyc7XG5pbXBvcnQgeyBUYWcgfSBmcm9tICcuLi9jZGstdG9vbGtpdCc7XG5pbXBvcnQgeyBkZWJ1ZywgZXJyb3IsIHByaW50IH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyB0b1lBTUwgfSBmcm9tICcuLi9zZXJpYWxpemUnO1xuaW1wb3J0IHsgQXNzZXRNYW5pZmVzdEJ1aWxkZXIgfSBmcm9tICcuLi91dGlsL2Fzc2V0LW1hbmlmZXN0LWJ1aWxkZXInO1xuaW1wb3J0IHsgcHVibGlzaEFzc2V0cyB9IGZyb20gJy4uL3V0aWwvYXNzZXQtcHVibGlzaGluZyc7XG5pbXBvcnQgeyBjb250ZW50SGFzaCB9IGZyb20gJy4uL3V0aWwvY29udGVudC1oYXNoJztcbmltcG9ydCB7IElTREssIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyB0cnlIb3Rzd2FwRGVwbG95bWVudCB9IGZyb20gJy4vaG90c3dhcC1kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBJQ09OIH0gZnJvbSAnLi9ob3Rzd2FwL2NvbW1vbic7XG5pbXBvcnQgeyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uIH0gZnJvbSAnLi9ob3Rzd2FwL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcbmltcG9ydCB7IFRvb2xraXRJbmZvIH0gZnJvbSAnLi90b29sa2l0LWluZm8nO1xuaW1wb3J0IHtcbiAgY2hhbmdlU2V0SGFzTm9DaGFuZ2VzLCBDbG91ZEZvcm1hdGlvblN0YWNrLCBUZW1wbGF0ZVBhcmFtZXRlcnMsIHdhaXRGb3JDaGFuZ2VTZXQsXG4gIHdhaXRGb3JTdGFja0RlcGxveSwgd2FpdEZvclN0YWNrRGVsZXRlLCBQYXJhbWV0ZXJWYWx1ZXMsIFBhcmFtZXRlckNoYW5nZXMsXG59IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5TW9uaXRvciwgU3RhY2tBY3Rpdml0eVByb2dyZXNzIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uL3N0YWNrLWFjdGl2aXR5LW1vbml0b3InO1xuXG50eXBlIFRlbXBsYXRlQm9keVBhcmFtZXRlciA9IHtcbiAgVGVtcGxhdGVCb2R5Pzogc3RyaW5nXG4gIFRlbXBsYXRlVVJMPzogc3RyaW5nXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveVN0YWNrUmVzdWx0IHtcbiAgcmVhZG9ubHkgbm9PcDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgb3V0cHV0czogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHJlYWRvbmx5IHN0YWNrQXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXBsb3lTdGFja09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHN0YWNrIHRvIGJlIGRlcGxveWVkXG4gICAqL1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuXG4gIC8qKlxuICAgKiBUaGUgZW52aXJvbm1lbnQgdG8gZGVwbG95IHRoaXMgc3RhY2sgaW5cbiAgICpcbiAgICogVGhlIGVudmlyb25tZW50IG9uIHRoZSBzdGFjayBhcnRpZmFjdCBtYXkgYmUgdW5yZXNvbHZlZCwgdGhpcyBvbmVcbiAgICogbXVzdCBiZSByZXNvbHZlZC5cbiAgICovXG4gIHJlc29sdmVkRW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50O1xuXG4gIC8qKlxuICAgKiBUaGUgU0RLIHRvIHVzZSBmb3IgZGVwbG95aW5nIHRoZSBzdGFja1xuICAgKlxuICAgKiBTaG91bGQgaGF2ZSBiZWVuIGluaXRpYWxpemVkIHdpdGggdGhlIGNvcnJlY3Qgcm9sZSB3aXRoIHdoaWNoXG4gICAqIHN0YWNrIG9wZXJhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAgICovXG4gIHNkazogSVNESztcblxuICAvKipcbiAgICogU0RLIHByb3ZpZGVyIChzZWVkZWQgd2l0aCBkZWZhdWx0IGNyZWRlbnRpYWxzKVxuICAgKlxuICAgKiBXaWxsIGV4Y2x1c2l2ZWx5IGJlIHVzZWQgdG8gYXNzdW1lIHB1Ymxpc2hpbmcgY3JlZGVudGlhbHMgKHdoaWNoIG11c3RcbiAgICogc3RhcnQgb3V0IGZyb20gY3VycmVudCBjcmVkZW50aWFscyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgd2UndmUgYXNzdW1lZCBhblxuICAgKiBhY3Rpb24gcm9sZSB0byB0b3VjaCB0aGUgc3RhY2sgb3Igbm90KS5cbiAgICpcbiAgICogVXNlZCBmb3IgdGhlIGZvbGxvd2luZyBwdXJwb3NlczpcbiAgICpcbiAgICogLSBQdWJsaXNoIGxlZ2FjeSBhc3NldHMuXG4gICAqIC0gVXBsb2FkIGxhcmdlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlcyB0byB0aGUgc3RhZ2luZyBidWNrZXQuXG4gICAqL1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBib290c3RyYXAgc3RhY2sgZm91bmQgaW4gdGhlIHRhcmdldCBlbnZpcm9ubWVudFxuICAgKi9cbiAgdG9vbGtpdEluZm86IFRvb2xraXRJbmZvO1xuXG4gIC8qKlxuICAgKiBSb2xlIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gdG8gZXhlY3V0ZSB0aGUgY2hhbmdlIHNldFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFJvbGUgc3BlY2lmaWVkIG9uIHN0YWNrLCBvdGhlcndpc2UgY3VycmVudFxuICAgKi9cbiAgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogTm90aWZpY2F0aW9uIEFSTnMgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiB0byBub3RpZnkgd2hlbiB0aGUgY2hhbmdlIHNldCBoYXMgY29tcGxldGVkXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gbm90aWZpY2F0aW9uc1xuICAgKi9cbiAgbm90aWZpY2F0aW9uQXJucz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBOYW1lIHRvIGRlcGxveSB0aGUgc3RhY2sgdW5kZXJcbiAgICpcbiAgICogQGRlZmF1bHQgLSBOYW1lIGZyb20gYXNzZW1ibHlcbiAgICovXG4gIGRlcGxveU5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFF1aWV0IG9yIHZlcmJvc2UgZGVwbG95bWVudFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcXVpZXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IElEcyB3aGljaCBzaG91bGRuJ3QgYmUgYnVpbHRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBCdWlsZCBhbGwgYXNzZXRzXG4gICAqL1xuICByZXVzZUFzc2V0cz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUYWdzIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gdG8gYWRkIHRvIHN0YWNrXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gdGFnc1xuICAgKi9cbiAgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGV4ZWN1dGUgdGhlIGNoYW5nZXNldCBvciBsZWF2ZSBpdCBpbiByZXZpZXcuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGV4ZWN1dGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBuYW1lIHRvIHVzZSBmb3IgdGhlIENsb3VkRm9ybWF0aW9uIGNoYW5nZSBzZXQuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgYSBuYW1lIHdpbGwgYmUgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqL1xuICBjaGFuZ2VTZXROYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29sbGVjdGlvbiBvZiBleHRyYSBwYXJhbWV0ZXJzXG4gICAqIChpbiBhZGRpdGlvbiB0byB0aG9zZSB1c2VkIGZvciBhc3NldHMpXG4gICAqIHRvIHBhc3MgdG8gdGhlIGRlcGxveWVkIHRlbXBsYXRlLlxuICAgKiBOb3RlIHRoYXQgcGFyYW1ldGVycyB3aXRoIGB1bmRlZmluZWRgIG9yIGVtcHR5IHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQsXG4gICAqIGFuZCBub3QgcGFzc2VkIHRvIHRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRlbXBsYXRlXG4gICAqL1xuICBwYXJhbWV0ZXJzPzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbiAgLyoqXG4gICAqIFVzZSBwcmV2aW91cyB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogSWYgbm90IHNldCwgYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGV2ZXJ5IGRlcGxveW1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB1c2VQcmV2aW91c1BhcmFtZXRlcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEaXNwbGF5IG1vZGUgZm9yIHN0YWNrIGRlcGxveW1lbnQgcHJvZ3Jlc3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CYXIgc3RhY2sgZXZlbnRzIHdpbGwgYmUgZGlzcGxheWVkIGZvclxuICAgKiAgIHRoZSByZXNvdXJjZSBjdXJyZW50bHkgYmVpbmcgZGVwbG95ZWQuXG4gICAqL1xuICBwcm9ncmVzcz86IFN0YWNrQWN0aXZpdHlQcm9ncmVzcztcblxuICAvKipcbiAgICogRGVwbG95IGV2ZW4gaWYgdGhlIGRlcGxveWVkIHRlbXBsYXRlIGlzIGlkZW50aWNhbCB0byB0aGUgb25lIHdlIGFyZSBhYm91dCB0byBkZXBsb3kuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmb3JjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UgYXJlIG9uIGEgQ0kgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBjaT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIGZhaWxlZCBkZXBsb3ltZW50c1xuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSByb2xsYmFjaz86IGJvb2xlYW47XG5cbiAgLypcbiAgICogV2hldGhlciB0byBwZXJmb3JtIGEgJ2hvdHN3YXAnIGRlcGxveW1lbnQuXG4gICAqIEEgJ2hvdHN3YXAnIGRlcGxveW1lbnQgd2lsbCBhdHRlbXB0IHRvIHNob3J0LWNpcmN1aXQgQ2xvdWRGb3JtYXRpb25cbiAgICogYW5kIHVwZGF0ZSB0aGUgYWZmZWN0ZWQgcmVzb3VyY2VzIGxpa2UgTGFtYmRhIGZ1bmN0aW9ucyBkaXJlY3RseS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBmYWxzZSBmb3IgcmVndWxhciBkZXBsb3ltZW50cywgdHJ1ZSBmb3IgJ3dhdGNoJyBkZXBsb3ltZW50c1xuICAgKi9cbiAgcmVhZG9ubHkgaG90c3dhcD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBleHRyYSBzdHJpbmcgdG8gYXBwZW5kIHRvIHRoZSBVc2VyLUFnZW50IGhlYWRlciB3aGVuIHBlcmZvcm1pbmcgQVdTIFNESyBjYWxscy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBub3RoaW5nIGV4dHJhIGlzIGFwcGVuZGVkIHRvIHRoZSBVc2VyLUFnZW50IGhlYWRlclxuICAgKi9cbiAgcmVhZG9ubHkgZXh0cmFVc2VyQWdlbnQ/OiBzdHJpbmc7XG59XG5cbmNvbnN0IExBUkdFX1RFTVBMQVRFX1NJWkVfS0IgPSA1MDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcGxveVN0YWNrKG9wdGlvbnM6IERlcGxveVN0YWNrT3B0aW9ucyk6IFByb21pc2U8RGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhY2tBcnRpZmFjdCA9IG9wdGlvbnMuc3RhY2s7XG5cbiAgY29uc3Qgc3RhY2tFbnYgPSBvcHRpb25zLnJlc29sdmVkRW52aXJvbm1lbnQ7XG5cbiAgb3B0aW9ucy5zZGsuYXBwZW5kQ3VzdG9tVXNlckFnZW50KG9wdGlvbnMuZXh0cmFVc2VyQWdlbnQpO1xuICBjb25zdCBjZm4gPSBvcHRpb25zLnNkay5jbG91ZEZvcm1hdGlvbigpO1xuICBjb25zdCBkZXBsb3lOYW1lID0gb3B0aW9ucy5kZXBsb3lOYW1lIHx8IHN0YWNrQXJ0aWZhY3Quc3RhY2tOYW1lO1xuICBsZXQgY2xvdWRGb3JtYXRpb25TdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgZGVwbG95TmFtZSk7XG5cbiAgaWYgKGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tTdGF0dXMuaXNDcmVhdGlvbkZhaWx1cmUpIHtcbiAgICBkZWJ1ZyhgRm91bmQgZXhpc3Rpbmcgc3RhY2sgJHtkZXBsb3lOYW1lfSB0aGF0IGhhZCBwcmV2aW91c2x5IGZhaWxlZCBjcmVhdGlvbi4gRGVsZXRpbmcgaXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmUtY3JlYXRlIGl0LmApO1xuICAgIGF3YWl0IGNmbi5kZWxldGVTdGFjayh7IFN0YWNrTmFtZTogZGVwbG95TmFtZSB9KS5wcm9taXNlKCk7XG4gICAgY29uc3QgZGVsZXRlZFN0YWNrID0gYXdhaXQgd2FpdEZvclN0YWNrRGVsZXRlKGNmbiwgZGVwbG95TmFtZSk7XG4gICAgaWYgKGRlbGV0ZWRTdGFjayAmJiBkZWxldGVkU3RhY2suc3RhY2tTdGF0dXMubmFtZSAhPT0gJ0RFTEVURV9DT01QTEVURScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIGRlbGV0aW5nIHN0YWNrICR7ZGVwbG95TmFtZX0gdGhhdCBoYWQgcHJldmlvdXNseSBmYWlsZWQgY3JlYXRpb24gKGN1cnJlbnQgc3RhdGU6ICR7ZGVsZXRlZFN0YWNrLnN0YWNrU3RhdHVzfSlgKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHZhcmlhYmxlIHRvIG1hcmsgdGhhdCB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QgYW55bW9yZSwgYnV0IGF2b2lkXG4gICAgLy8gZG9pbmcgYW4gYWN0dWFsIGxvb2t1cCBpbiBDbG91ZEZvcm1hdGlvbiAod2hpY2ggd291bGQgYmUgc2lsbHkgdG8gZG8gaWZcbiAgICAvLyB3ZSBqdXN0IGRlbGV0ZWQgaXQpLlxuICAgIGNsb3VkRm9ybWF0aW9uU3RhY2sgPSBDbG91ZEZvcm1hdGlvblN0YWNrLmRvZXNOb3RFeGlzdChjZm4sIGRlcGxveU5hbWUpO1xuICB9XG5cbiAgLy8gRGV0ZWN0IFwibGVnYWN5XCIgYXNzZXRzICh3aGljaCByZW1haW4gaW4gdGhlIG1ldGFkYXRhKSBhbmQgcHVibGlzaCB0aGVtIHZpYVxuICAvLyBhbiBhZC1ob2MgYXNzZXQgbWFuaWZlc3QsIHdoaWxlIHBhc3NpbmcgdGhlaXIgbG9jYXRpb25zIHZpYSB0ZW1wbGF0ZVxuICAvLyBwYXJhbWV0ZXJzLlxuICBjb25zdCBsZWdhY3lBc3NldHMgPSBuZXcgQXNzZXRNYW5pZmVzdEJ1aWxkZXIoKTtcbiAgY29uc3QgYXNzZXRQYXJhbXMgPSBhd2FpdCBhZGRNZXRhZGF0YUFzc2V0c1RvTWFuaWZlc3Qoc3RhY2tBcnRpZmFjdCwgbGVnYWN5QXNzZXRzLCBvcHRpb25zLnRvb2xraXRJbmZvLCBvcHRpb25zLnJldXNlQXNzZXRzKTtcblxuICBjb25zdCBmaW5hbFBhcmFtZXRlclZhbHVlcyA9IHsgLi4ub3B0aW9ucy5wYXJhbWV0ZXJzLCAuLi5hc3NldFBhcmFtcyB9O1xuXG4gIGNvbnN0IHRlbXBsYXRlUGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZShzdGFja0FydGlmYWN0LnRlbXBsYXRlKTtcbiAgY29uc3Qgc3RhY2tQYXJhbXMgPSBvcHRpb25zLnVzZVByZXZpb3VzUGFyYW1ldGVyc1xuICAgID8gdGVtcGxhdGVQYXJhbXMudXBkYXRlRXhpc3RpbmcoZmluYWxQYXJhbWV0ZXJWYWx1ZXMsIGNsb3VkRm9ybWF0aW9uU3RhY2sucGFyYW1ldGVycylcbiAgICA6IHRlbXBsYXRlUGFyYW1zLnN1cHBseUFsbChmaW5hbFBhcmFtZXRlclZhbHVlcyk7XG5cbiAgaWYgKGF3YWl0IGNhblNraXBEZXBsb3kob3B0aW9ucywgY2xvdWRGb3JtYXRpb25TdGFjaywgc3RhY2tQYXJhbXMuaGFzQ2hhbmdlcyhjbG91ZEZvcm1hdGlvblN0YWNrLnBhcmFtZXRlcnMpKSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBza2lwcGluZyBkZXBsb3ltZW50ICh1c2UgLS1mb3JjZSB0byBvdmVycmlkZSlgKTtcbiAgICAvLyBpZiB3ZSBjYW4gc2tpcCBkZXBsb3ltZW50IGFuZCB3ZSBhcmUgcGVyZm9ybWluZyBhIGhvdHN3YXAsIGxldCB0aGUgdXNlciBrbm93XG4gICAgLy8gdGhhdCBubyBob3Rzd2FwIGRlcGxveW1lbnQgaGFwcGVuZWRcbiAgICBpZiAob3B0aW9ucy5ob3Rzd2FwKSB7XG4gICAgICBwcmludChgXFxuICR7SUNPTn0gJXNcXG5gLCBjb2xvcnMuYm9sZCgnaG90c3dhcCBkZXBsb3ltZW50IHNraXBwZWQgLSBubyBjaGFuZ2VzIHdlcmUgZGV0ZWN0ZWQgKHVzZSAtLWZvcmNlIHRvIG92ZXJyaWRlKScpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vT3A6IHRydWUsXG4gICAgICBvdXRwdXRzOiBjbG91ZEZvcm1hdGlvblN0YWNrLm91dHB1dHMsXG4gICAgICBzdGFja0FybjogY2xvdWRGb3JtYXRpb25TdGFjay5zdGFja0lkLFxuICAgICAgc3RhY2tBcnRpZmFjdCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBkZXBsb3lpbmcuLi5gKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHlQYXJhbWV0ZXIgPSBhd2FpdCBtYWtlQm9keVBhcmFtZXRlcihzdGFja0FydGlmYWN0LCBvcHRpb25zLnJlc29sdmVkRW52aXJvbm1lbnQsIGxlZ2FjeUFzc2V0cywgb3B0aW9ucy50b29sa2l0SW5mbywgb3B0aW9ucy5zZGspO1xuICBhd2FpdCBwdWJsaXNoQXNzZXRzKGxlZ2FjeUFzc2V0cy50b01hbmlmZXN0KHN0YWNrQXJ0aWZhY3QuYXNzZW1ibHkuZGlyZWN0b3J5KSwgb3B0aW9ucy5zZGtQcm92aWRlciwgc3RhY2tFbnYpO1xuXG4gIGlmIChvcHRpb25zLmhvdHN3YXApIHtcbiAgICAvLyBhdHRlbXB0IHRvIHNob3J0LWNpcmN1aXQgdGhlIGRlcGxveW1lbnQgaWYgcG9zc2libGVcbiAgICB0cnkge1xuICAgICAgY29uc3QgaG90c3dhcERlcGxveW1lbnRSZXN1bHQgPSBhd2FpdCB0cnlIb3Rzd2FwRGVwbG95bWVudChvcHRpb25zLnNka1Byb3ZpZGVyLCBhc3NldFBhcmFtcywgY2xvdWRGb3JtYXRpb25TdGFjaywgc3RhY2tBcnRpZmFjdCk7XG4gICAgICBpZiAoaG90c3dhcERlcGxveW1lbnRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGhvdHN3YXBEZXBsb3ltZW50UmVzdWx0O1xuICAgICAgfVxuICAgICAgcHJpbnQoJ0NvdWxkIG5vdCBwZXJmb3JtIGEgaG90c3dhcCBkZXBsb3ltZW50LCBhcyB0aGUgc3RhY2sgJXMgY29udGFpbnMgbm9uLUFzc2V0IGNoYW5nZXMnLCBzdGFja0FydGlmYWN0LmRpc3BsYXlOYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHByaW50KCdDb3VsZCBub3QgcGVyZm9ybSBhIGhvdHN3YXAgZGVwbG95bWVudCwgYmVjYXVzZSB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUgY291bGQgbm90IGJlIHJlc29sdmVkOiAlcycsIGUubWVzc2FnZSk7XG4gICAgfVxuICAgIHByaW50KCdGYWxsaW5nIGJhY2sgdG8gZG9pbmcgYSBmdWxsIGRlcGxveW1lbnQnKTtcbiAgfVxuXG4gIC8vIGNvdWxkIG5vdCBzaG9ydC1jaXJjdWl0IHRoZSBkZXBsb3ltZW50LCBwZXJmb3JtIGEgZnVsbCBDRk4gZGVwbG95IGluc3RlYWRcbiAgcmV0dXJuIHByZXBhcmVBbmRFeGVjdXRlQ2hhbmdlU2V0KG9wdGlvbnMsIGNsb3VkRm9ybWF0aW9uU3RhY2ssIHN0YWNrQXJ0aWZhY3QsIHN0YWNrUGFyYW1zLCBib2R5UGFyYW1ldGVyKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUFuZEV4ZWN1dGVDaGFuZ2VTZXQoXG4gIG9wdGlvbnM6IERlcGxveVN0YWNrT3B0aW9ucywgY2xvdWRGb3JtYXRpb25TdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjayxcbiAgc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LCBzdGFja1BhcmFtczogUGFyYW1ldGVyVmFsdWVzLCBib2R5UGFyYW1ldGVyOiBUZW1wbGF0ZUJvZHlQYXJhbWV0ZXIsXG4pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gIC8vIGlmIHdlIGdvdCBoZXJlLCBhbmQgaG90c3dhcCBpcyBlbmFibGVkLCB0aGF0IG1lYW5zIGNoYW5nZXMgY291bGRuJ3QgYmUgaG90c3dhcHBlZCxcbiAgLy8gYW5kIHdlIGhhZCB0byBmYWxsIGJhY2sgb24gYSBmdWxsIGRlcGxveW1lbnQuIE5vdGUgdGhhdCBmYWN0IGluIG91ciBVc2VyLUFnZW50XG4gIGlmIChvcHRpb25zLmhvdHN3YXApIHtcbiAgICBvcHRpb25zLnNkay5hcHBlbmRDdXN0b21Vc2VyQWdlbnQoJ2Nkay1ob3Rzd2FwL2ZhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBjZm4gPSBvcHRpb25zLnNkay5jbG91ZEZvcm1hdGlvbigpO1xuICBjb25zdCBkZXBsb3lOYW1lID0gb3B0aW9ucy5kZXBsb3lOYW1lID8/IHN0YWNrQXJ0aWZhY3Quc3RhY2tOYW1lO1xuXG4gIGNvbnN0IGNoYW5nZVNldE5hbWUgPSBvcHRpb25zLmNoYW5nZVNldE5hbWUgPz8gJ2Nkay1kZXBsb3ktY2hhbmdlLXNldCc7XG4gIGlmIChjbG91ZEZvcm1hdGlvblN0YWNrLmV4aXN0cykge1xuICAgIC8vRGVsZXRlIGFueSBleGlzdGluZyBjaGFuZ2Ugc2V0cyBnZW5lcmF0ZWQgYnkgQ0RLIHNpbmNlIGNoYW5nZSBzZXQgbmFtZXMgbXVzdCBiZSB1bmlxdWUuXG4gICAgLy9UaGUgZGVsZXRlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBhcyBsb25nIGFzIHRoZSBzdGFjayBleGlzdHMgKGV2ZW4gaWYgdGhlIGNoYW5nZSBzZXQgZG9lcyBub3QgZXhpc3QpLlxuICAgIGRlYnVnKGBSZW1vdmluZyBleGlzdGluZyBjaGFuZ2Ugc2V0IHdpdGggbmFtZSAke2NoYW5nZVNldE5hbWV9IGlmIGl0IGV4aXN0c2ApO1xuICAgIGF3YWl0IGNmbi5kZWxldGVDaGFuZ2VTZXQoeyBTdGFja05hbWU6IGRlcGxveU5hbWUsIENoYW5nZVNldE5hbWU6IGNoYW5nZVNldE5hbWUgfSkucHJvbWlzZSgpO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlID0gY2xvdWRGb3JtYXRpb25TdGFjay5leGlzdHMgJiYgY2xvdWRGb3JtYXRpb25TdGFjay5zdGFja1N0YXR1cy5uYW1lICE9PSAnUkVWSUVXX0lOX1BST0dSRVNTJztcblxuICBkZWJ1ZyhgQXR0ZW1wdGluZyB0byBjcmVhdGUgQ2hhbmdlU2V0IHdpdGggbmFtZSAke2NoYW5nZVNldE5hbWV9IHRvICR7dXBkYXRlID8gJ3VwZGF0ZScgOiAnY3JlYXRlJ30gc3RhY2sgJHtkZXBsb3lOYW1lfWApO1xuICBwcmludCgnJXM6IGNyZWF0aW5nIENsb3VkRm9ybWF0aW9uIGNoYW5nZXNldC4uLicsIGNvbG9ycy5ib2xkKGRlcGxveU5hbWUpKTtcbiAgY29uc3QgZXhlY3V0aW9uSWQgPSB1dWlkLnY0KCk7XG4gIGNvbnN0IGNoYW5nZVNldCA9IGF3YWl0IGNmbi5jcmVhdGVDaGFuZ2VTZXQoe1xuICAgIFN0YWNrTmFtZTogZGVwbG95TmFtZSxcbiAgICBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lLFxuICAgIENoYW5nZVNldFR5cGU6IHVwZGF0ZSA/ICdVUERBVEUnIDogJ0NSRUFURScsXG4gICAgRGVzY3JpcHRpb246IGBDREsgQ2hhbmdlc2V0IGZvciBleGVjdXRpb24gJHtleGVjdXRpb25JZH1gLFxuICAgIFRlbXBsYXRlQm9keTogYm9keVBhcmFtZXRlci5UZW1wbGF0ZUJvZHksXG4gICAgVGVtcGxhdGVVUkw6IGJvZHlQYXJhbWV0ZXIuVGVtcGxhdGVVUkwsXG4gICAgUGFyYW1ldGVyczogc3RhY2tQYXJhbXMuYXBpUGFyYW1ldGVycyxcbiAgICBSb2xlQVJOOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgTm90aWZpY2F0aW9uQVJOczogb3B0aW9ucy5ub3RpZmljYXRpb25Bcm5zLFxuICAgIENhcGFiaWxpdGllczogWydDQVBBQklMSVRZX0lBTScsICdDQVBBQklMSVRZX05BTUVEX0lBTScsICdDQVBBQklMSVRZX0FVVE9fRVhQQU5EJ10sXG4gICAgVGFnczogb3B0aW9ucy50YWdzLFxuICB9KS5wcm9taXNlKCk7XG4gIGRlYnVnKCdJbml0aWF0ZWQgY3JlYXRpb24gb2YgY2hhbmdlc2V0OiAlczsgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoIGNyZWF0aW5nLi4uJywgY2hhbmdlU2V0LklkKTtcbiAgY29uc3QgY2hhbmdlU2V0RGVzY3JpcHRpb24gPSBhd2FpdCB3YWl0Rm9yQ2hhbmdlU2V0KGNmbiwgZGVwbG95TmFtZSwgY2hhbmdlU2V0TmFtZSk7XG5cbiAgLy8gVXBkYXRlIHRlcm1pbmF0aW9uIHByb3RlY3Rpb24gb25seSBpZiBpdCBoYXMgY2hhbmdlZC5cbiAgY29uc3QgdGVybWluYXRpb25Qcm90ZWN0aW9uID0gc3RhY2tBcnRpZmFjdC50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gZmFsc2U7XG4gIGlmICghIWNsb3VkRm9ybWF0aW9uU3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uICE9PSB0ZXJtaW5hdGlvblByb3RlY3Rpb24pIHtcbiAgICBkZWJ1ZygnVXBkYXRpbmcgdGVybWluYXRpb24gcHJvdGVjdGlvbiBmcm9tICVzIHRvICVzIGZvciBzdGFjayAlcycsIGNsb3VkRm9ybWF0aW9uU3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uLCB0ZXJtaW5hdGlvblByb3RlY3Rpb24sIGRlcGxveU5hbWUpO1xuICAgIGF3YWl0IGNmbi51cGRhdGVUZXJtaW5hdGlvblByb3RlY3Rpb24oe1xuICAgICAgU3RhY2tOYW1lOiBkZXBsb3lOYW1lLFxuICAgICAgRW5hYmxlVGVybWluYXRpb25Qcm90ZWN0aW9uOiB0ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgfSkucHJvbWlzZSgpO1xuICAgIGRlYnVnKCdUZXJtaW5hdGlvbiBwcm90ZWN0aW9uIHVwZGF0ZWQgdG8gJXMgZm9yIHN0YWNrICVzJywgdGVybWluYXRpb25Qcm90ZWN0aW9uLCBkZXBsb3lOYW1lKTtcbiAgfVxuXG4gIGlmIChjaGFuZ2VTZXRIYXNOb0NoYW5nZXMoY2hhbmdlU2V0RGVzY3JpcHRpb24pKSB7XG4gICAgZGVidWcoJ05vIGNoYW5nZXMgYXJlIHRvIGJlIHBlcmZvcm1lZCBvbiAlcy4nLCBkZXBsb3lOYW1lKTtcbiAgICBpZiAob3B0aW9ucy5leGVjdXRlKSB7XG4gICAgICBkZWJ1ZygnRGVsZXRpbmcgZW1wdHkgY2hhbmdlIHNldCAlcycsIGNoYW5nZVNldC5JZCk7XG4gICAgICBhd2FpdCBjZm4uZGVsZXRlQ2hhbmdlU2V0KHsgU3RhY2tOYW1lOiBkZXBsb3lOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lIH0pLnByb21pc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9PcDogdHJ1ZSwgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzLCBzdGFja0FybjogY2hhbmdlU2V0LlN0YWNrSWQhLCBzdGFja0FydGlmYWN0IH07XG4gIH1cblxuICBjb25zdCBleGVjdXRlID0gb3B0aW9ucy5leGVjdXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5leGVjdXRlO1xuICBpZiAoZXhlY3V0ZSkge1xuICAgIGRlYnVnKCdJbml0aWF0aW5nIGV4ZWN1dGlvbiBvZiBjaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMnLCBjaGFuZ2VTZXQuSWQsIGRlcGxveU5hbWUpO1xuXG4gICAgY29uc3Qgc2hvdWxkRGlzYWJsZVJvbGxiYWNrID0gb3B0aW9ucy5yb2xsYmFjayA9PT0gZmFsc2U7XG4gICAgLy8gRG8gYSBiaXQgb2YgY29udG9ydGlvbnMgdG8gb25seSBwYXNzIHRoZSBgRGlzYWJsZVJvbGxiYWNrYCBmbGFnIGlmIGl0J3MgdHJ1ZS4gVGhhdCB3YXksXG4gICAgLy8gQ2xvdWRGb3JtYXRpb24gd29uJ3QgYmFsayBhdCB0aGUgdW5yZWNvZ25pemVkIG9wdGlvbiBpbiByZWdpb25zIHdoZXJlIHRoZSBmZWF0dXJlIGlzIG5vdCBhdmFpbGFibGUgeWV0LlxuICAgIGNvbnN0IGRpc2FibGVSb2xsYmFjayA9IHNob3VsZERpc2FibGVSb2xsYmFjayA/IHsgRGlzYWJsZVJvbGxiYWNrOiB0cnVlIH0gOiB1bmRlZmluZWQ7XG5cbiAgICBhd2FpdCBjZm4uZXhlY3V0ZUNoYW5nZVNldCh7IFN0YWNrTmFtZTogZGVwbG95TmFtZSwgQ2hhbmdlU2V0TmFtZTogY2hhbmdlU2V0TmFtZSwgLi4uZGlzYWJsZVJvbGxiYWNrIH0pLnByb21pc2UoKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgY29uc3QgY2hhbmdlU2V0TGVuZ3RoOiBudW1iZXIgPSAoY2hhbmdlU2V0RGVzY3JpcHRpb24uQ2hhbmdlcyA/PyBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IG1vbml0b3IgPSBvcHRpb25zLnF1aWV0ID8gdW5kZWZpbmVkIDogU3RhY2tBY3Rpdml0eU1vbml0b3Iud2l0aERlZmF1bHRQcmludGVyKGNmbiwgZGVwbG95TmFtZSwgc3RhY2tBcnRpZmFjdCwge1xuICAgICAgLy8gKzEgZm9yIHRoZSBleHRyYSBldmVudCBlbWl0dGVkIGZyb20gdXBkYXRlcy5cbiAgICAgIHJlc291cmNlc1RvdGFsOiBjbG91ZEZvcm1hdGlvblN0YWNrLmV4aXN0cyA/IGNoYW5nZVNldExlbmd0aCArIDEgOiBjaGFuZ2VTZXRMZW5ndGgsXG4gICAgICBwcm9ncmVzczogb3B0aW9ucy5wcm9ncmVzcyxcbiAgICAgIGNoYW5nZVNldENyZWF0aW9uVGltZTogY2hhbmdlU2V0RGVzY3JpcHRpb24uQ3JlYXRpb25UaW1lLFxuICAgIH0pLnN0YXJ0KCk7XG4gICAgZGVidWcoJ0V4ZWN1dGlvbiBvZiBjaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMgaGFzIHN0YXJ0ZWQ7IHdhaXRpbmcgZm9yIHRoZSB1cGRhdGUgdG8gY29tcGxldGUuLi4nLCBjaGFuZ2VTZXQuSWQsIGRlcGxveU5hbWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmaW5hbFN0YWNrID0gYXdhaXQgd2FpdEZvclN0YWNrRGVwbG95KGNmbiwgZGVwbG95TmFtZSk7XG5cbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IHJlYWxseSBoYXBwZW4sIGJ1dCBjYXRjaCBpdCBhbnl3YXkuIFlvdSBuZXZlciBrbm93LlxuICAgICAgaWYgKCFmaW5hbFN0YWNrKSB7IHRocm93IG5ldyBFcnJvcignU3RhY2sgZGVwbG95IGZhaWxlZCAodGhlIHN0YWNrIGRpc2FwcGVhcmVkIHdoaWxlIHdlIHdlcmUgZGVwbG95aW5nIGl0KScpOyB9XG4gICAgICBjbG91ZEZvcm1hdGlvblN0YWNrID0gZmluYWxTdGFjaztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgbW9uaXRvcj8uc3RvcCgpO1xuICAgIH1cbiAgICBkZWJ1ZygnU3RhY2sgJXMgaGFzIGNvbXBsZXRlZCB1cGRhdGluZycsIGRlcGxveU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHByaW50KCdDaGFuZ2VzZXQgJXMgY3JlYXRlZCBhbmQgd2FpdGluZyBpbiByZXZpZXcgZm9yIG1hbnVhbCBleGVjdXRpb24gKC0tbm8tZXhlY3V0ZSknLCBjaGFuZ2VTZXQuSWQpO1xuICB9XG5cbiAgcmV0dXJuIHsgbm9PcDogZmFsc2UsIG91dHB1dHM6IGNsb3VkRm9ybWF0aW9uU3RhY2sub3V0cHV0cywgc3RhY2tBcm46IGNoYW5nZVNldC5TdGFja0lkISwgc3RhY2tBcnRpZmFjdCB9O1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBib2R5IHBhcmFtZXRlciBmb3IgK0NyZWF0ZUNoYW5nZVNldCsuXG4gKlxuICogSWYgdGhlIHRlbXBsYXRlIGlzIHNtYWxsIGVub3VnaCB0byBiZSBpbmxpbmVkIGludG8gdGhlIEFQSSBjYWxsLCBqdXN0IHJldHVyblxuICogaXQgaW1tZWRpYXRlbHkuXG4gKlxuICogT3RoZXJ3aXNlLCBhZGQgaXQgdG8gdGhlIGFzc2V0IG1hbmlmZXN0IHRvIGdldCB1cGxvYWRlZCB0byB0aGUgc3RhZ2luZ1xuICogYnVja2V0IGFuZCByZXR1cm4gaXRzIGNvb3JkaW5hdGVzLiBJZiB0aGVyZSBpcyBubyBzdGFnaW5nIGJ1Y2tldCwgYW4gZXJyb3JcbiAqIGlzIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gc3RhY2sgICAgIHRoZSBzeW50aGVzaXplZCBzdGFjayB0aGF0IHByb3ZpZGVzIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZVxuICogQHBhcmFtIHRvb2xraXRJbmZvIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0b29sa2l0IHN0YWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1ha2VCb2R5UGFyYW1ldGVyKFxuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICByZXNvbHZlZEVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyxcbiAgc2RrOiBJU0RLKTogUHJvbWlzZTxUZW1wbGF0ZUJvZHlQYXJhbWV0ZXI+IHtcblxuICAvLyBJZiB0aGUgdGVtcGxhdGUgaGFzIGFscmVhZHkgYmVlbiB1cGxvYWRlZCB0byBTMywganVzdCB1c2UgaXQgZnJvbSB0aGVyZS5cbiAgaWYgKHN0YWNrLnN0YWNrVGVtcGxhdGVBc3NldE9iamVjdFVybCkge1xuICAgIHJldHVybiB7IFRlbXBsYXRlVVJMOiByZXN0VXJsRnJvbU1hbmlmZXN0KHN0YWNrLnN0YWNrVGVtcGxhdGVBc3NldE9iamVjdFVybCwgcmVzb2x2ZWRFbnZpcm9ubWVudCwgc2RrKSB9O1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBwYXNzIHZpYSBBUEkgY2FsbCAoaWYgc21hbGwpIG9yIHVwbG9hZCBoZXJlIChpZiBsYXJnZSlcbiAgY29uc3QgdGVtcGxhdGVKc29uID0gdG9ZQU1MKHN0YWNrLnRlbXBsYXRlKTtcblxuICBpZiAodGVtcGxhdGVKc29uLmxlbmd0aCA8PSBMQVJHRV9URU1QTEFURV9TSVpFX0tCICogMTAyNCkge1xuICAgIHJldHVybiB7IFRlbXBsYXRlQm9keTogdGVtcGxhdGVKc29uIH07XG4gIH1cblxuICBpZiAoIXRvb2xraXRJbmZvLmZvdW5kKSB7XG4gICAgZXJyb3IoXG4gICAgICBgVGhlIHRlbXBsYXRlIGZvciBzdGFjayBcIiR7c3RhY2suZGlzcGxheU5hbWV9XCIgaXMgJHtNYXRoLnJvdW5kKHRlbXBsYXRlSnNvbi5sZW5ndGggLyAxMDI0KX1LaUIuIGAgK1xuICAgICAgYFRlbXBsYXRlcyBsYXJnZXIgdGhhbiAke0xBUkdFX1RFTVBMQVRFX1NJWkVfS0J9S2lCIG11c3QgYmUgdXBsb2FkZWQgdG8gUzMuXFxuYCArXG4gICAgICAnUnVuIHRoZSBmb2xsb3dpbmcgY29tbWFuZCBpbiBvcmRlciB0byBzZXR1cCBhbiBTMyBidWNrZXQgaW4gdGhpcyBlbnZpcm9ubWVudCwgYW5kIHRoZW4gcmUtZGVwbG95OlxcblxcbicsXG4gICAgICBjb2xvcnMuYmx1ZShgXFx0JCBjZGsgYm9vdHN0cmFwICR7cmVzb2x2ZWRFbnZpcm9ubWVudC5uYW1lfVxcbmApKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignVGVtcGxhdGUgdG9vIGxhcmdlIHRvIGRlcGxveSAoXCJjZGsgYm9vdHN0cmFwXCIgaXMgcmVxdWlyZWQpJyk7XG4gIH1cblxuICBjb25zdCB0ZW1wbGF0ZUhhc2ggPSBjb250ZW50SGFzaCh0ZW1wbGF0ZUpzb24pO1xuICBjb25zdCBrZXkgPSBgY2RrLyR7c3RhY2suaWR9LyR7dGVtcGxhdGVIYXNofS55bWxgO1xuXG4gIGFzc2V0TWFuaWZlc3QuYWRkRmlsZUFzc2V0KHRlbXBsYXRlSGFzaCwge1xuICAgIHBhdGg6IHN0YWNrLnRlbXBsYXRlRmlsZSxcbiAgfSwge1xuICAgIGJ1Y2tldE5hbWU6IHRvb2xraXRJbmZvLmJ1Y2tldE5hbWUsXG4gICAgb2JqZWN0S2V5OiBrZXksXG4gIH0pO1xuXG4gIGNvbnN0IHRlbXBsYXRlVVJMID0gYCR7dG9vbGtpdEluZm8uYnVja2V0VXJsfS8ke2tleX1gO1xuICBkZWJ1ZygnU3RvcmluZyB0ZW1wbGF0ZSBpbiBTMyBhdDonLCB0ZW1wbGF0ZVVSTCk7XG4gIHJldHVybiB7IFRlbXBsYXRlVVJMOiB0ZW1wbGF0ZVVSTCB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlc3Ryb3lTdGFja09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHN0YWNrIHRvIGJlIGRlc3Ryb3llZFxuICAgKi9cbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcblxuICBzZGs6IElTREs7XG4gIHJvbGVBcm4/OiBzdHJpbmc7XG4gIGRlcGxveU5hbWU/OiBzdHJpbmc7XG4gIHF1aWV0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlc3Ryb3lTdGFjayhvcHRpb25zOiBEZXN0cm95U3RhY2tPcHRpb25zKSB7XG4gIGNvbnN0IGRlcGxveU5hbWUgPSBvcHRpb25zLmRlcGxveU5hbWUgfHwgb3B0aW9ucy5zdGFjay5zdGFja05hbWU7XG4gIGNvbnN0IGNmbiA9IG9wdGlvbnMuc2RrLmNsb3VkRm9ybWF0aW9uKCk7XG5cbiAgY29uc3QgY3VycmVudFN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBkZXBsb3lOYW1lKTtcbiAgaWYgKCFjdXJyZW50U3RhY2suZXhpc3RzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1vbml0b3IgPSBvcHRpb25zLnF1aWV0ID8gdW5kZWZpbmVkIDogU3RhY2tBY3Rpdml0eU1vbml0b3Iud2l0aERlZmF1bHRQcmludGVyKGNmbiwgZGVwbG95TmFtZSwgb3B0aW9ucy5zdGFjaykuc3RhcnQoKTtcblxuICB0cnkge1xuICAgIGF3YWl0IGNmbi5kZWxldGVTdGFjayh7IFN0YWNrTmFtZTogZGVwbG95TmFtZSwgUm9sZUFSTjogb3B0aW9ucy5yb2xlQXJuIH0pLnByb21pc2UoKTtcbiAgICBjb25zdCBkZXN0cm95ZWRTdGFjayA9IGF3YWl0IHdhaXRGb3JTdGFja0RlbGV0ZShjZm4sIGRlcGxveU5hbWUpO1xuICAgIGlmIChkZXN0cm95ZWRTdGFjayAmJiBkZXN0cm95ZWRTdGFjay5zdGFja1N0YXR1cy5uYW1lICE9PSAnREVMRVRFX0NPTVBMRVRFJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVzdHJveSAke2RlcGxveU5hbWV9OiAke2Rlc3Ryb3llZFN0YWNrLnN0YWNrU3RhdHVzfWApO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAobW9uaXRvcikgeyBhd2FpdCBtb25pdG9yLnN0b3AoKTsgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgd2UgY2FuIHNraXAgZGVwbG95bWVudFxuICpcbiAqIFdlIGRvIHRoaXMgaW4gYSBjb21wbGljYXRlZCB3YXkgYnkgcHJlcHJvY2Vzc2luZyAoaW5zdGVhZCBvZiBqdXN0XG4gKiBsb29raW5nIGF0IHRoZSBjaGFuZ2VzZXQpLCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBuZXN0ZWQgc3RhY2tzIGludm9sdmVkXG4gKiB0aGUgY2hhbmdlc2V0IHdpbGwgYWx3YXlzIHNob3cgdGhlIG5lc3RlZCBzdGFja3MgYXMgbmVlZGluZyB0byBiZVxuICogdXBkYXRlZCwgYW5kIHRoZSBkZXBsb3ltZW50IHdpbGwgdGFrZSBhIGxvbmcgdGltZSB0byBpbiBlZmZlY3Qgbm90XG4gKiBkbyBhbnl0aGluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2FuU2tpcERlcGxveShcbiAgZGVwbG95U3RhY2tPcHRpb25zOiBEZXBsb3lTdGFja09wdGlvbnMsXG4gIGNsb3VkRm9ybWF0aW9uU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2ssXG4gIHBhcmFtZXRlckNoYW5nZXM6IFBhcmFtZXRlckNoYW5nZXMpOiBQcm9taXNlPGJvb2xlYW4+IHtcblxuICBjb25zdCBkZXBsb3lOYW1lID0gZGVwbG95U3RhY2tPcHRpb25zLmRlcGxveU5hbWUgfHwgZGVwbG95U3RhY2tPcHRpb25zLnN0YWNrLnN0YWNrTmFtZTtcbiAgZGVidWcoYCR7ZGVwbG95TmFtZX06IGNoZWNraW5nIGlmIHdlIGNhbiBza2lwIGRlcGxveWApO1xuXG4gIC8vIEZvcmNlZCBkZXBsb3lcbiAgaWYgKGRlcGxveVN0YWNrT3B0aW9ucy5mb3JjZSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBmb3JjZWQgZGVwbG95bWVudGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENyZWF0aW5nIGNoYW5nZXNldCBvbmx5IChkZWZhdWx0IHRydWUpLCBuZXZlciBza2lwXG4gIGlmIChkZXBsb3lTdGFja09wdGlvbnMuZXhlY3V0ZSA9PT0gZmFsc2UpIHtcbiAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogLS1uby1leGVjdXRlLCBhbHdheXMgY3JlYXRpbmcgY2hhbmdlIHNldGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE5vIGV4aXN0aW5nIHN0YWNrXG4gIGlmICghY2xvdWRGb3JtYXRpb25TdGFjay5leGlzdHMpIHtcbiAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogbm8gZXhpc3Rpbmcgc3RhY2tgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZW1wbGF0ZSBoYXMgY2hhbmdlZCAoYXNzZXRzIHRha2VuIGludG8gYWNjb3VudCBoZXJlKVxuICBpZiAoSlNPTi5zdHJpbmdpZnkoZGVwbG95U3RhY2tPcHRpb25zLnN0YWNrLnRlbXBsYXRlKSAhPT0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgY2xvdWRGb3JtYXRpb25TdGFjay50ZW1wbGF0ZSgpKSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiB0ZW1wbGF0ZSBoYXMgY2hhbmdlZGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRhZ3MgaGF2ZSBjaGFuZ2VkXG4gIGlmICghY29tcGFyZVRhZ3MoY2xvdWRGb3JtYXRpb25TdGFjay50YWdzLCBkZXBsb3lTdGFja09wdGlvbnMudGFncyA/PyBbXSkpIHtcbiAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogdGFncyBoYXZlIGNoYW5nZWRgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXJtaW5hdGlvbiBwcm90ZWN0aW9uIGhhcyBiZWVuIHVwZGF0ZWRcbiAgaWYgKCEhZGVwbG95U3RhY2tPcHRpb25zLnN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiAhPT0gISFjbG91ZEZvcm1hdGlvblN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbikge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiB0ZXJtaW5hdGlvbiBwcm90ZWN0aW9uIGhhcyBiZWVuIHVwZGF0ZWRgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBQYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZFxuICBpZiAocGFyYW1ldGVyQ2hhbmdlcykge1xuICAgIGlmIChwYXJhbWV0ZXJDaGFuZ2VzID09PSAnc3NtJykge1xuICAgICAgZGVidWcoYCR7ZGVwbG95TmFtZX06IHNvbWUgcGFyYW1ldGVycyBjb21lIGZyb20gU1NNIHNvIHdlIGhhdmUgdG8gYXNzdW1lIHRoZXkgbWF5IGhhdmUgY2hhbmdlZGApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogcGFyYW1ldGVycyBoYXZlIGNoYW5nZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXhpc3Rpbmcgc3RhY2sgaXMgaW4gYSBmYWlsZWQgc3RhdGVcbiAgaWYgKGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tTdGF0dXMuaXNGYWlsdXJlKSB7XG4gICAgZGVidWcoYCR7ZGVwbG95TmFtZX06IHN0YWNrIGlzIGluIGEgZmFpbHVyZSBzdGF0ZWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdlIGNhbiBza2lwIGRlcGxveVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gbGlzdCBvZiB0YWdzLCByZXR1cm5zIHRydWUgaWYgaWRlbnRpY2FsLlxuICovXG5mdW5jdGlvbiBjb21wYXJlVGFncyhhOiBUYWdbXSwgYjogVGFnW10pOiBib29sZWFuIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgYVRhZyBvZiBhKSB7XG4gICAgY29uc3QgYlRhZyA9IGIuZmluZCh0YWcgPT4gdGFnLktleSA9PT0gYVRhZy5LZXkpO1xuXG4gICAgaWYgKCFiVGFnIHx8IGJUYWcuVmFsdWUgIT09IGFUYWcuVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYW4gUzMgVVJMIGluIHRoZSBtYW5pZmVzdCBmb3IgdXNlIHdpdGggQ2xvdWRGb3JtYXRpb25cbiAqXG4gKiBSZXBsYWNlcyBlbnZpcm9ubWVudCBwbGFjZWhvbGRlcnMgKHdoaWNoIHRoaXMgZmllbGQgbWF5IGNvbnRhaW4pLFxuICogYW5kIHJlZm9ybWF0cyBzMzovLy4uLi8uLi4gdXJscyBpbnRvIFMzIFJFU1QgVVJMcyAod2hpY2ggQ2xvdWRGb3JtYXRpb25cbiAqIGV4cGVjdHMpXG4gKi9cbmZ1bmN0aW9uIHJlc3RVcmxGcm9tTWFuaWZlc3QodXJsOiBzdHJpbmcsIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrOiBJU0RLKTogc3RyaW5nIHtcbiAgY29uc3QgZG9Ob3RVc2VNYXJrZXIgPSAnKipET05PVFVTRSoqJztcbiAgLy8gVGhpcyBVUkwgbWF5IGNvbnRhaW4gcGxhY2Vob2xkZXJzLCBzbyBzdGlsbCBzdWJzdGl0dXRlIHRob3NlLlxuICB1cmwgPSBjeGFwaS5FbnZpcm9ubWVudFBsYWNlaG9sZGVycy5yZXBsYWNlKHVybCwge1xuICAgIGFjY291bnRJZDogZW52aXJvbm1lbnQuYWNjb3VudCxcbiAgICByZWdpb246IGVudmlyb25tZW50LnJlZ2lvbixcbiAgICBwYXJ0aXRpb246IGRvTm90VXNlTWFya2VyLFxuICB9KTtcblxuICAvLyBZZXMsIHRoaXMgaXMgZXh0cmVtZWx5IGNydWRlLCBidXQgd2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGlzIHNvIEknbSBub3QgaW5jbGluZWQgdG8gc3BlbmRcbiAgLy8gYSBsb3Qgb2YgZWZmb3J0IHRyeWluZyB0byB0aHJlYWQgdGhlIHJpZ2h0IHZhbHVlIHRvIHRoaXMgbG9jYXRpb24uXG4gIGlmICh1cmwuaW5kZXhPZihkb05vdFVzZU1hcmtlcikgPiAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBcXCcke0FXUzo6UGFydGl0aW9ufVxcJyBpbiB0aGUgXFwnc3RhY2tUZW1wbGF0ZUFzc2V0T2JqZWN0VXJsXFwnIGZpZWxkJyk7XG4gIH1cblxuICBjb25zdCBzM1VybCA9IHVybC5tYXRjaCgvczM6XFwvXFwvKFteL10rKVxcLyguKikkLyk7XG4gIGlmICghczNVcmwpIHsgcmV0dXJuIHVybDsgfVxuXG4gIC8vIFdlIG5lZWQgdG8gcGFzcyBhbiAnaHR0cHM6Ly9zMy5SRUdJT04uYW1hem9uYXdzLmNvbVsuY25dL2J1Y2tldC9vYmplY3QnIFVSTCB0byBDbG91ZEZvcm1hdGlvbiwgYnV0IHdlXG4gIC8vIGdvdCBhbiAnczM6Ly9idWNrZXQvb2JqZWN0JyBVUkwgaW5zdGVhZC4gQ29uc3RydWN0IHRoZSByZXN0IEFQSSBVUkwgaGVyZS5cbiAgY29uc3QgYnVja2V0TmFtZSA9IHMzVXJsWzFdO1xuICBjb25zdCBvYmplY3RLZXkgPSBzM1VybFsyXTtcblxuICBjb25zdCB1cmxTdWZmaXg6IHN0cmluZyA9IHNkay5nZXRFbmRwb2ludFN1ZmZpeChlbnZpcm9ubWVudC5yZWdpb24pO1xuICByZXR1cm4gYGh0dHBzOi8vczMuJHtlbnZpcm9ubWVudC5yZWdpb259LiR7dXJsU3VmZml4fS8ke2J1Y2tldE5hbWV9LyR7b2JqZWN0S2V5fWA7XG59XG4iXX0=